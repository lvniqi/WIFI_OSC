/*thread_example.c :  c multiple thread programming in linux
  *author : lvniqi
  *E-mail : lvniqi@gmail.com
  */
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/time.h>

#include "Sequeue.h"
#define MAX 7
#define UDP_IN_PORT 55554
#define UDP_PORT 55555
#define TCP_PORT 55556
pthread_mutex_t count_lock;//自旋锁  
pthread_mutex_t addr_lock;//地址锁
pthread_cond_t count_nonzero;//条件锁 
unsigned count = 0;
char client_addr[5][16];
pthread_mutex_t mut;
int number=0, i;

void connectTcp(char* addr,int port){
    struct sockaddr_in sock_tcp;
    int sock_fd;
    #define MAXLINE 4096
    char buf[MAXLINE];
    char str[MAXLINE];
    int result;
    /*防止写入失败*/
    signal(SIGPIPE,SIG_IGN);
    bzero(&sock_tcp, sizeof(sock_tcp));
    
    sock_tcp.sin_family = AF_INET;
    inet_pton(AF_INET, addr, &sock_tcp.sin_addr);
    sock_tcp.sin_port = htons(port);
    
    sock_fd = socket(AF_INET, SOCK_STREAM, 0);
    result=connect(sock_fd, (void *)&sock_tcp, sizeof(sock_tcp));
    if(result <0){
        perror("call connect");
        exit(1);
    }
    int len;
    /*while(1) {
        len = recv(sock_fd,buf,200,0);
        if(len<0){
            printf("error comming!\n");
            break;
        }
        if(0 == len){
            printf("the othere side has been closed.\n");
            break;
        }
        else{
            printf("receive from server:%s\n",buf);
        }
    }*/
    close(sock_fd); 
}
/*
 * 数据发送
 * */
void *sendData() {  
    pthread_mutex_lock(&addr_lock);
    
    pthread_mutex_unlock(&addr_lock);
    //等待线程:1使用pthread_cond_wait前要先加锁
    //2pthread_cond_wait内部会解锁，然后等待条件变量被其它线程激活  
    //pthread_cond_wait(&count_nonzero, &count_lock); 
    //printf("get ip address:\t%s\n","0.0.0.0");  
    //pthread_cond_signal(&count_nonzero); 
    //pthread_mutex_unlock(&count_lock);
}  
 /*
  * 条件锁测试
  */
void *getIp()  {  
    struct sockaddr_in addr;
    //IPV4
    addr.sin_family = AF_INET;
    //prot
    addr.sin_port = htons(UDP_IN_PORT);
    //任意地址
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    int sock;
    if ( (sock = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP)) < 0){
        perror("socket");
        exit(1);
    }
    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0){
        perror("bind");
        exit(1);
    }
    #define BUFFER_LEN 1000
    char buff[BUFFER_LEN];
    struct sockaddr_in clientAddr;
    int message_len;
    int len = sizeof(clientAddr);
    while (1){
        message_len = recvfrom(sock, buff,BUFFER_LEN-1, 0, (struct sockaddr*)&clientAddr, &len);
        if(message_len >0){
            buff[message_len] = 0;
		    printf("len:%d\n",message_len);
            if(0 == strcmp(inet_ntoa(clientAddr.sin_addr),buff)){
                printf("Ip: %s\n",buff);
                connectTcp(buff,TCP_PORT);
            }
        }
        else{
            perror("recv");
            break;
        }
    }

    pthread_mutex_lock(&count_lock);         
    //激活线程：1加锁（和等待线程用同一个锁）  
    pthread_cond_signal(&count_nonzero);
    pthread_mutex_unlock(&count_lock); 
}  
int main()
{
        /*
         * 测试 条件锁
         */
        printf("测试条件锁！\n----\n");
        pthread_t tid1, tid2;
        pthread_mutex_init(&count_lock, NULL);
        pthread_cond_init(&count_nonzero, NULL);
        pthread_create(&tid1, NULL, sendData, NULL);
        sleep(1);
        pthread_create(&tid2, NULL, getIp, NULL);
        sleep(1);
        printf("after sleep 1 second begin exit!\n");
        pthread_exit(0);
        return 0;
}
